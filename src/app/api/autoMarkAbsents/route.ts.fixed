// filepath: c:\Users\Edbert\attendify\src\app\api\autoMarkAbsents\route.ts
import { NextResponse } from 'next/server';
import admin, { getFirestoreAdmin } from '@/lib/firebase-admin';

// Get a Firestore instance using our custom initialization function
const db = getFirestoreAdmin();

// Convert any time format to 24-hour format
function normalizeTimeFormat(timeStr: string): string | null {
  if (!timeStr) return null;
  
  // If already in 24-hour format (like "14:30"), return as is
  if (/^[0-2]?[0-9]:[0-5][0-9]$/.test(timeStr)) {
    return timeStr;
  }
  
  try {
    // Handle formats like "2:30 pm"
    timeStr = timeStr.toLowerCase();
    let [time, meridiem] = timeStr.split(' ');
    let [hours, minutes] = time.split(':').map(Number);
    
    if (meridiem === 'pm' && hours < 12) {
      hours += 12;
    } else if (meridiem === 'am' && hours === 12) {
      hours = 0;
    }
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  } catch (error) {
    console.error(`[API autoMarkAbsents] Error normalizing time format: ${timeStr}`, error);
    return null;
  }
}

export async function GET(request: Request) {
  // Check if db was successfully initialized
  if (!db) {
    console.error("[API autoMarkAbsents] CRITICAL: Firestore DB is not initialized. This likely means Firebase Admin SDK setup failed. Please check server logs for earlier initialization errors and verify all Firebase-related environment variables in .env.local are correct.");
    return NextResponse.json({ error: 'Server configuration error: Firebase services not available.' }, { status: 500 });
  }
  // 1. Secure your endpoint: Check for a secret key from the cron job 
  // or verify it's coming from Vercel's cron system
  const authHeader = request.headers.get('authorization');
  const isVercelCron = request.headers.get('x-vercel-cron') === 'true';
  
  if (!(authHeader === `Bearer ${process.env.CRON_SECRET}` || isVercelCron)) {
    console.warn('[API autoMarkAbsents] Unauthorized attempt');
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  console.log('[API autoMarkAbsents] Request authorized, starting process.');

  // 2. Implement your logic (similar to your current Firebase Function)
  try {
    const now = new Date();
    const todayStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
    const daysOfWeek = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const todayDay = daysOfWeek[now.getDay()];
    console.log(`[API autoMarkAbsents] Running at ${now.toISOString()} (${todayDay})`);

    const classroomsSnap = await db
      .collection("classrooms")
      .where("archived", "==", false)
      .get();
    
    console.log(`[API autoMarkAbsents] Found ${classroomsSnap.size} non-archived classrooms.`);
    
    let markedAbsentCount = 0;
    let checkedSessionsCount = 0;

    for (const classroomDoc of classroomsSnap.docs) {
      const classroom = classroomDoc.data();
      const classCode = classroomDoc.id;
      // Ensure sessions is an array, default to empty if not or undefined
      const sessions = Array.isArray(classroom.sessions) ? classroom.sessions : [];
      
      console.log(`[API autoMarkAbsents] Processing classroom ${classCode} (${classroom.name || 'unnamed'}), ${sessions.length} sessions`);
      
      if (!sessions.length) {
        console.log(`[API autoMarkAbsents] Class ${classCode} has no sessions defined. Skipping.`);
        continue;
      }

      for (const session of sessions) {
        // Validate session structure
        if (!session.day) {
          console.warn(`[API autoMarkAbsents] Class ${classCode} has a session with missing day. Skipping.`);
          continue;
        }

        if (!session.endTime) {
          console.warn(`[API autoMarkAbsents] Class ${classCode} has a session with missing endTime. Skipping.`);
          continue;
        }
        
        // Normalize the session day to match our expected format
        // Some classrooms might have "monday" instead of "Monday"
        const normalizedDay = session.day.charAt(0).toUpperCase() + session.day.slice(1).toLowerCase();
        const sessionDay = normalizedDay;
        
        if (todayDay !== sessionDay) {
          console.log(`[API autoMarkAbsents] Session day "${sessionDay}" does not match today (${todayDay}). Skipping.`);
          continue; // Not the correct day for this session
        }

        // Normalize time formats (handle "2:30 pm" style formats)
        const sessionEndTime = normalizeTimeFormat(session.endTime); // "HH:mm"
        if (!sessionEndTime) {
          console.warn(`[API autoMarkAbsents] Class ${classCode} has an invalid endTime format: ${session.endTime}. Skipping.`);
          continue;
        }
        
        checkedSessionsCount++;

        const [endHour, endMinute] = sessionEndTime.split(":").map(Number);
        const sessionEnd = new Date(now); // Use a copy of 'now' to avoid modifying it
        sessionEnd.setHours(endHour, endMinute, 0, 0); // Set to today's date with session's end time

        // Normalize the start time as well
        const sessionStartTime = normalizeTimeFormat(session.startTime);
        if (!sessionStartTime) {
          console.warn(`[API autoMarkAbsents] Class ${classCode} has an invalid startTime format: ${session.startTime}. Using default.`);
        }
        
        // Parse start time for logging purposes only
        let startHour = 0;
        let startMinute = 0;
        
        if (sessionStartTime) {
          [startHour, startMinute] = sessionStartTime.split(":").map(Number);
        }
        
        const sessionStart = new Date(now);
        sessionStart.setHours(startHour, startMinute, 0, 0);
        
        // Log the times for easier debugging
        console.log(`[API autoMarkAbsents] Current time (now): ${now.toISOString()}`);
        console.log(`[API autoMarkAbsents] Session start time for ${classCode}: ${sessionStart.toISOString()}`);
        console.log(`[API autoMarkAbsents] Session end time for ${classCode}: ${sessionEnd.toISOString()}`);
        
        // Calculate time differences
        const timeDiffFromEnd = now.getTime() - sessionEnd.getTime();
        const thirtyMinutesInMillis = 30 * 60 * 1000;

        console.log(`[API autoMarkAbsents] Time difference for ${classCode} session ${session.day} ${sessionEndTime}: ${timeDiffFromEnd / 60000} minutes since end.`);

        // Check if the session has ended today and within the last 30 minutes
        const isAfterClassEnded = now > sessionEnd && timeDiffFromEnd < thirtyMinutesInMillis && timeDiffFromEnd >= 0;
        
        if (isAfterClassEnded) {
          console.log(`[API autoMarkAbsents] Processing class ${classCode} session ${sessionDay} ${sessionEndTime} for ABSENT marking.`);
          
          const studentsSnap = await db.collection("students")
            .where("classCode", "==", classCode)
            .get();

          if (studentsSnap.empty) {
            console.log(`[API autoMarkAbsents] No students found for class ${classCode}.`);
            continue;
          }

          for (const studentDoc of studentsSnap.docs) {
            const student = studentDoc.data();
            const studentId = student.studentId;

            if (!studentId) {
                console.warn(`[API autoMarkAbsents] Student in class ${classCode} missing studentId. Doc ID: ${studentDoc.id}`);
                continue;
            }
            
            // Check if attendance exists for this session (today, for this subject if available)
            // Timestamp for query should be for the specific session's date (today)
            const sessionDateStart = new Date(todayStr + "T00:00:00.000Z");
            const sessionDateEnd = new Date(todayStr + "T23:59:59.999Z");
            let attendanceQuery = db.collection("attendance")
              .where("classCode", "==", classCode)
              .where("studentId", "==", studentId)
              .where("timestamp", ">=", admin.firestore.Timestamp.fromDate(sessionDateStart))
              .where("timestamp", "<=", admin.firestore.Timestamp.fromDate(sessionDateEnd));
              
            // If the session has a subject, include it in the query
            if (session.subject) {
              console.log(`[API autoMarkAbsents] Checking attendance for specific subject: ${session.subject}`);
              attendanceQuery = attendanceQuery.where("subject", "==", session.subject);
            } else {
              console.log(`[API autoMarkAbsents] No subject specified for this session. Checking any attendance for the day.`);
            }
            
            const attendanceSnap = await attendanceQuery.get();
            
            if (attendanceSnap.empty) {
              // Mark as absent
              const subjectName = session.subject || null;
              console.log(`[API autoMarkAbsents] Marking absent: studentId=${studentId}, classCode=${classCode}, sessionDay=${sessionDay}, sessionEndTime=${sessionEndTime}, subject=${subjectName}`);
              const attendanceRecord = await db.collection("attendance").add({
                classCode,
                studentId,
                studentName: student.fullName || "",
                subject: subjectName, // Use the session's subject if available
                timestamp: admin.firestore.Timestamp.fromDate(sessionEnd), // Timestamp of when the session ended
                status: "absent",
                proofImage: null,
                excuse: null,
                excuseFile: null,
                submittedTime: admin.firestore.Timestamp.now(), // When this record was created
                isLate: false,
                geolocation: null,
              });
              markedAbsentCount++;
              
              // Create notification for auto-marked absence
              try {
                // Get class name for the notification
                const classData = classroomDoc.data();
                const className = classData.name || classCode;
                
                // Create notification record
                await db.collection("notifications").add({
                  userId: studentId,
                  title: "Marked as Absent",
                  message: `You have been marked as ABSENT in ${className} for ${sessionDay}.`,
                  type: "error",
                  read: false,
                  timestamp: admin.firestore.Timestamp.now(),
                  relatedDoc: {
                    type: "attendance",
                    id: attendanceRecord.id
                  },
                  extraData: {
                    classCode,
                    className,
                    date: sessionEnd.toLocaleDateString()
                  }
                });
                console.log(`[API autoMarkAbsents] Created absence notification for studentId=${studentId}, classCode=${classCode}`);
              } catch (notifError) {
                console.error(`[API autoMarkAbsents] Error creating notification for studentId=${studentId}:`, notifError);
                // Continue processing even if notification creation fails
              }
            } else {
              console.log(`[API autoMarkAbsents] Attendance found for studentId=${studentId}, classCode=${classCode} for session on ${sessionDay} ending ${sessionEndTime}`);
            }
          }
        } else {
          let skipReason = '';
          if (now <= sessionEnd) skipReason = 'session has not ended yet';
          else if (timeDiffFromEnd >= thirtyMinutesInMillis) skipReason = 'session ended more than 30 minutes ago';
          else if (timeDiffFromEnd < 0) skipReason = 'session end time is in the future relative to current time (clock sync issue?)';
          else skipReason = 'condition not met for an unknown reason';
          console.log(`[API autoMarkAbsents] Skipping class ${classCode} session ${sessionDay} ${sessionEndTime}. Reason: ${skipReason}.`);
        }
      }
    }
    
    console.log(`[API autoMarkAbsents] Finished. Checked ${checkedSessionsCount} sessions. Marked ${markedAbsentCount} students absent.`);
    return NextResponse.json({ 
      success: true, 
      checkedSessions: checkedSessionsCount, 
      markedAbsentCount
    });
  } catch (error) {
    console.error("[API autoMarkAbsents] Error in autoMarkAbsents API route:", error);
    // It's good practice to check the type of error if possible
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: 'Internal Server Error', details: errorMessage }, { status: 500 });
  }
}
